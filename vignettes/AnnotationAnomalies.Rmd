---
title: "Detection and Analysis of Annotation Anomalies"
author:
    - name: Anthony Christidis
      affiliation:
        - &core_affiliation Core for Computational Biomedicine, Harvard Medical School
    - name: Andrew Ghazi
      affiliation:
        - *core_affiliation
    - name: Smriti Chawla
      affiliation:
        - *core_affiliation
    - name: Nitesh Turaga
      affiliation:
        - *core_affiliation
    - name: Ludwig Geistlinger
      affiliation:
        - *core_affiliation
    - name: Robert Gentleman
      affiliation:
        - *core_affiliation
package: scDiagnostics
output: 
  BiocStyle::html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{4. Detection and Analysis of Annotation Anomalies}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include = FALSE, fig.show='hide'}
knitr::knit_hooks$set(pngquant = knitr::hook_pngquant)

knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>",
dev = "ragg_png",
dpi = 72,
fig.retina = 2,
fig.align = "center",
out.width = "100%",
pngquant = "--speed=1 --quality=1-5"
)
```

# Introduction 

The `scDiagnostics` package provides powerful tools for anomaly detection in single-cell data, enabling researchers to identify and analyze outliers in complex datasets. Central to this process is the `detectAnomaly()` function, which integrates dimensionality reduction through Principal Component Analysis (PCA) with the robust capabilities of the isolation forest algorithm.

In single-cell analysis, detecting anomalies is crucial for identifying potential data issues, such as mislabeled cells, technical artifacts, or biologically distinct subpopulations. The `detectAnomaly()` function offers a versatile approach to anomaly detection by allowing users to project data onto a PCA space and apply isolation forests to uncover outliers. Whether working solely with a reference dataset or comparing a query dataset against a well-characterized reference, this function provides detailed insights into potential anomalies.

This vignette illustrates how to effectively use the `detectAnomaly()` function in various scenarios. We explore both cell-type-specific and global anomaly detection, demonstrate the utility of integrating query data with reference data, and offer guidance on interpreting the results. Additionally, we show how to extend this analysis by combining anomaly detection with PCA loadings using the `calculateCellSimilarityPCA()` function, providing a comprehensive toolkit for investigating the structure and quality of single-cell data.

This vignette also demonstrates the use of two functions, `calculateCellDistances()` and `calculateCellDistancesSimilarity()`, to analyze the distances between cells in query and reference datasets and to measure the similarity of density distributions. These functions are useful for investigating how cells in different datasets relate to each other, particularly in the context of identifying anomalies and understanding distribution overlaps.

# Preliminaries

In the context of the `scDiagnostics` package, the following datasets illustrate the application of these tools:

- `reference_data`: A curated and processed dataset containing expert-assigned cell type annotations. This dataset serves as a reference for comparison and can be used alone to detect anomalies within the reference annotations.

- `query_data`: A dataset that also includes expert-assigned cell type annotations, but additionally features annotations generated by the `r BiocStyle::Biocpkg("SingleR")` package. This allows for the comparison of expert annotations with those produced by an automated method to detect inconsistencies or anomalies.

```{r, message=FALSE, fig.show='hide'}
# Load library
library(scDiagnostics)

# Load datasets
data("reference_data")
data("query_data")

# Set seed for reproducibility
set.seed(0)
```


By using these datasets, you can leverage the package's tools to compare annotations between `reference_data` and `query_data`, or analyze `reference_data` alone to identify potential issues. The packageâ€™s flexibility supports various analysis scenarios, whether you need to assess overall annotation quality or focus on specific cell types.

Through these capabilities, `scDiagnostics` empowers you to perform thorough and nuanced assessments of cell type annotations, enhancing the accuracy and reliability of your analyses.


# The `detectAnomaly()` Function 

## Function Overview  

### Description

The `detectAnomaly()` function integrates dimensionality reduction via PCA with the isolation forest algorithm to detect anomalies in single-cell data. By projecting both reference and query datasets (if available) onto the PCA space of the reference data, the function trains an isolation forest model on reference data in PCA space to pinpoint anomalies in the reference or query data. This approach is highly versatile:

- **Reference Only**: Compute anomaly scores solely for the reference dataset to identify potential issues within the reference itself.
- **Reference and Query**: Compare the query dataset against the reference to find anomalies in the query data that may not align with the established reference.
- **Global and Specific Analysis**: Assess anomalies at a global level or focus on specific cell types to gain targeted insights into your data.
The function also provides detailed visualizations and statistical outputs to help you interpret the anomalies detected.

### Parameters

The function takes a `r BiocStyle::Biocpkg("SingleCellExperiment")` object as `reference_data` and trains an isolation forest model on the reference PCA-projected data, with an optional `query_data` for projecting onto this PCA space for anomaly detection. You can specify cell type annotations through `ref_cell_type_col` and `query_cell_type_col`, and limit the analysis to certain cell types using the `cell_types` parameter. The function allows you to select specific principal components to use to train the isolation forest via `pc_subset`, adjust the number of trees with `n_tree`, and set an `anomaly_threshold` for classifying anomalies.


### Return Value

The function returns several outputs: `anomaly_scores` indicating the likelihood of each cell being an anomaly, a logical vector (`anomaly`) identifying these anomalies, PCA projections for the reference data (`reference_mat_subset`) and optionally for the query data (`query_mat_subset`), and the proportion of variance explained by the selected principal components (`var_explained`).



## `detectAnomaly()` Examples

### Anomaly Detection with Reference and Query Data

This section demonstrates how to use the `detectAnomaly()` function when both reference and query datasets are provided. It includes examples of analyzing anomalies for specific cell types and globally across all data.


#### Example 1: Cell-Type Specific Anomaly Detection
In this example, we analyze anomalies specifically for the "CD4" cell type. The anomaly scores are trained on the PCA projections of the "CD4" cells from the reference dataset. If query data is provided, anomaly scores for the query data are predicted based on the PCA projections of the query data onto the reference PCA space for the "CD4" cell type.




```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Perform anomaly detection
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data, 
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:5,
                                n_tree = 500,
                                anomaly_threshold = 0.6)

# Plot the output for the "CD4" cell type
plot(anomaly_output, 
     cell_type = "CD8", 
     pc_subset = 1:5, 
     data_type = "query")
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/detectAnomaly1.png)

In this example, we analyze anomalies specifically for the "CD4" cell type. The anomaly scores are trained on the PCA projections of the "CD4" cells from the reference dataset. If query data is provided, anomaly scores for the query data are predicted based on the PCA projections of the query data onto the reference PCA space for the "CD4" cell type.


#### Example 2: Global Anomaly Detection
Here, we perform global anomaly detection by setting `cell_type = NULL`. In this case, the isolation forest is trained on PCA projections of all cells in the reference data combined. The global anomaly scores are then computed for both reference and query datasets.

```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Perform anomaly detection
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data, 
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:5,
                                n_tree = 500,
                                anomaly_threshold = 0.6)

# Plot the global anomaly scores
plot(anomaly_output, 
     cell_type = NULL,  # Plot all cell types
     pc_subset = 1:5, 
     data_type = "query")
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/detectAnomaly2.png)

Setting `cell_type = NULL` means that the anomaly detection is done globally. The isolation forest is trained on PCA projections of all cells from the reference dataset. Anomaly scores are then predicted for the query data based on these global PCA projections. The plot provides a comprehensive view of anomalies across all cell types in the query dataset.

#### Anomaly Detection on Reference Data

Note that if you do not provide a query dataset to the `detectAnomaly()` function, the function will only return the anomaly output data on the reference data.


# Integrating Anomaly Detection with Cell Similarity Analysis Using PCA Loadings

The `detectAnomaly()` function identifies anomalous cells in a dataset by detecting outliers based on PCA results. Once anomalies are detected, `calculateCellSimilarityPCA()` evaluates how these outliers influence principal component directions. This analysis helps determine if anomalous cells significantly impact later PCs, which capture finer variations in the data. By combining these functions, you can both pinpoint anomalies and understand their effect on PCA directions, providing deeper insights into the data structure.
```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Detect anomalies and select top anomalies for further analysis
anomaly_output <- detectAnomaly(reference_data = reference_data, 
                                query_data = query_data,
                                ref_cell_type_col = "expert_annotation", 
                                query_cell_type_col = "SingleR_annotation",
                                pc_subset = 1:10,
                                n_tree = 500,
                                anomaly_threshold = 0.5)

# Select the top 6 anomalies based on the anomaly scores
top6_anomalies <- names(sort(anomaly_output$Combined$reference_anomaly_scores, 
                             decreasing = TRUE)[1:6])

# Calculate cosine similarity between the top anomalies and top 25 PCs
cosine_similarities <- calculateCellSimilarityPCA(reference_data, 
                                                  cell_names = top6_anomalies, 
                                                  pc_subset = 1:25, 
                                                  n_top_vars = 50)

# Plot the cosine similarities across PCs
round(cosine_similarities[, paste0("PC", 15:25)], 2)
```

Note that there is also a plot method for the object return for `calculateCellSimilarityPCA()`. See reference manual for details.

# Analyzing Cell Distances 

## `calculateCellDistances()`

The `calculateCellDistances()` function calculates Euclidean distances between cells within the reference dataset and between query cells and reference cells. This helps in understanding how closely related cells are within and across datasets based on their principal component (PC) scores.


## Function Usage
```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Compute cell distances
distance_data <- calculateCellDistances(
    query_data = query_data,
    reference_data = reference_data,
    query_cell_type_col = "SingleR_annotation",
    ref_cell_type_col = "expert_annotation",
    pc_subset = 1:10
)
```

In the code above:

- `query_data` and reference_data: These are `r BiocStyle::Biocpkg("SingleCellExperiment")` objects containing the respective datasets for analysis.
- `query_cell_type_col` and ref_cell_type_col: These arguments specify the columns in the `colData` of each dataset that contain cell type annotations.
- `pc_subset`: Specifies which principal components (1 to 10) are used to compute distances. PCA is applied for dimensionality reduction before calculating distances.

## Output
The output `distance_data` is a list where each entry contains:

- `ref_distances`: Pairwise distances within the reference dataset for each cell type.
- `query_to_ref_distances`: Distances from each query cell to all reference cells for each cell type.


## Example Workflow

In the example workflow, the first step involves plotting the distributions of cell distances for selected query cells against various reference cell populations. This involves visualizing both the distances between the query cells and the reference cells as well as the distances among the reference cells themselves. For each cell type, such as CD4 and CD8, these plots illustrate how the selected query cells compare in terms of their proximity to different reference populations.

```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Identify top 6 anomalies for CD4 cells
cd4_anomalies <- detectAnomaly(
  reference_data = reference_data,
  query_data = query_data,
  query_cell_type_col = "SingleR_annotation",
  ref_cell_type_col = "expert_annotation",
  pc_subset = 1:10,
  n_tree = 500,
  anomaly_threshold = 0.5)

# Top 6 CD4 anomalies
cd4_top6_anomalies <- names(sort(cd4_anomalies$CD4$query_anomaly_scores, decreasing = TRUE)[1:6])

# Plot distances for CD4 and CD8 cells
plot(distance_data, ref_cell_type = "CD4", cell_names = cd4_top6_anomalies)
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/calculateCellDistances1.png)

For CD4 cells, you might observe that the query cells are located much further away from the reference cells, indicating a significant divergence in their density distributions. This suggests that the CD4 query cells are less similar to the CD4 reference cells, showing greater variation or potential anomalies.


In contrast, for CD8 cells, the plots might reveal more overlap between the density distributions of query cells and reference cells. This overlap indicates that the CD8 query cells are more similar to the CD8 reference cells, suggesting better alignment or less divergence between their densities. Such insights are crucial for understanding how closely the query cells match with reference populations and can help in identifying cell types with notable differences or similarities.

```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Plot distances for CD8 cells
plot(distance_data, ref_cell_type = "CD8", cell_names = cd4_top6_anomalies)
```
![](https://raw.githubusercontent.com/ccb-hms/scDiagnostics/main/inst/extdata/compressed/AnnotationAnomalies/calculateCellDistances2.png)

## `calculateCellDistancesSimilarity()`

The `calculateCellDistancesSimilarity()` function measures how similar the density distributions of query cells are to those in the reference dataset. It computes **Bhattacharyya coefficients** and **Hellinger distances**, which quantify the overlap between the distributions.

The Bhattacharyya coefficient and Hellinger distance are two measures used to quantify the similarity between probability distributions. The Bhattacharyya coefficient ranges from 0 to 1, where a value closer to 1 indicates higher similarity between distributions, while a value closer to 0 suggests greater dissimilarity. The Hellinger distance, also ranging from 0 to 1, reflects the divergence between distributions, with lower values indicating greater similarity and higher values showing more distinct distributions. In the context of comparing query cells to reference cells, a high Bhattacharyya coefficient and a low Hellinger distance both suggest that the query cells have density profiles similar to those in the reference dataset, which can be desirable depending on the experimental objectives.

```{r, fig.height=5, fig.width=10, fig.show='hide'}
# Compute similarity measures for top 6 CD4 anomalies
overlap_measures <- calculateCellDistancesSimilarity(
  query_data = query_data,
  reference_data = reference_data,
  cell_names = cd4_top6_anomalies,
  query_cell_type_col = "SingleR_annotation",
  ref_cell_type_col = "expert_annotation",
  pc_subset = 1:10)
overlap_measures
```


------------------------------------------------------------------------

# R Session Info

```{r SessionInfo, echo=FALSE, message=FALSE, warning=FALSE, comment=NA, fig.show='hide'}
options(width = 80) 
sessionInfo()
```
